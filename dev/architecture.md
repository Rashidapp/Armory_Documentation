# Armory Architecture

Armory is built on several different technologies. Here is an overview of the different tools that Armory is built on from the ground up.

## Haxe

[Haxe](https://haxe.org) is a high level, cross-platform programming language that compiles to many other different [languages](https://haxe.org/documentation/introduction/compiler-targets.html). The targets of most importance to Armory games are the C (HL/C, see [HashLink](#/?id=hashlink)) target and the JavaScript target. Haxe is a strictly typed language that is well suited for large projects and has been used by many companies and individuals to create games and many other kinds of software.

Haxe is the primary programming language used to write most Armory games with Logic Nodes being another option for gameplay logic. C, C++, and JavaScript are also involved in different components. See [Runtimes](#/?id=runtimes). 

## Kha

[Kha](https://github.com/Kode/Kha) is a framework for writing cross-platform games with Haxe. It is an abstraction layer that allows you to separate your game from the platform that it runs on. Kha gives you a common API to graphics, audio, input, and networking, for a large collection of [platforms](https://github.com/Kode/Kha/wiki/Features#supported-platforms) and Graphics APIs. You can publish Kha games to Web, Mobile, Desktop, and Consoles while supporting OpenGL, WebGL, DirectX, Vulcan, and Metal graphics APIs.

All Armory games *are* Kha games. Armory blends are exported to Kha games before they are run and the generated Kha game is compiled for your target platform using Kha.

Kha isn't just an API or a library; it is a tool-set that includes a build system for Kha games called [khamake](https://github.com/Kode/khamake), and a shader cross-compiler, [Krafix](https://github.com/Kode/krafix), that allows it its support for multiple graphics APIs.

### Kha Targets

Out of Kha's many [targets](https://github.com/Kode/Kha/wiki/Features), the ones we are most interested in are C++ ( with Kore ), Krom, Web, and HashLink (HL).

#### Kore ( C++ )

[Kore](https://github.com/Kode/Kore) is the cross-platform C++ library that backs Kha's C++ target. It implements the whole Kha API for native targets and can be used to publish games to Windows, Linux, MacOS, and game consoles. [Khamake](https://github.com/Kode/khamake) is used similar to CMake to generate Linux ( Makefile/Code::Blocks ), Windows ( Visual Studio ), and MacOS ( XCode ) projects that you can compile using the platform's native tools.

Armory has recently moved away from using the C++ target to using the HashLink C (HL/C) target, which also leverages Kore very similarly to the C++ target.

#### Krom

Krom is a target developed specifically for Kha that is designed to allow rapid development and debugging of Kha games. Krom is essentially the Kore library with complete bindings to Javascript using either Microsoft's Chakra ( default ) or Chrome's V8 Javascript engine. Because Haxe can compile to Javascript *very* quickly, Krom allows you to build and run your game in seconds as opposed to waiting for a lengthy C++ build. Krom also features a built-in debugger that can be utilized in the [Kode Studio](https://github.com/Kode/KodeStudio) ( and potentially the Kha VSCode plugin ) IDE.

#### Web

Kha can publish games for web in seconds. The performance in browsers is supposed to be about 20% slower than Krom, and there are some graphics features such as Tessellation that that are not supported in Web ( WebGL ).

#### HashLink ( HL )

[HashLink](https://hashlink.haxe.org/) is a virtual machine ( a runtime environment ) for Haxe that can either run HashLink bytecode generated by Haxe or it can be compiled to C code which is then compiled using a C compiler, for optimum efficiency. In Armory, HashLink is used to generate C code for compiling native binaries for each platform.

The HashLink target is very similar to the C++ target of Kha and uses Kore for all of the core functionality just like the C++ target. The difference between the C++ and HashLink targets is that they have a different garbage collector and method of generating the code.

## Iron

While Kha gives you a way to interact with low level graphics and input in a standardized way across all platforms, [Iron](https://armory3d.org/iron/#/) gives you a higher level interface to useful features for building games. Iron is a game engine built on top of Kha and implemented as a collection of Haxe libraries. From the website:

> Iron handles render & content pipelines and lets you develop a custom visual engine on top of it.

Iron is the core of Armory3D and, along with other libraries developed in tandem, allows you to create advanced 3D games with Haxe.

## Armory3D

[Armory](https://armory3d.org) is a [Blender](https://blender.org) plugin that allows you to create Kha games with Blender. Armory takes your blender scenes and automatically exports all of the objects to the Armory format and and structures the export as a Kha game. It builds a workflow that allows you to go instantly from Blender to your game without having to deal with an Asset import/export workflow. Everything you make in Blender can instantly go into your game.

The Armory Blender plugin is written in Python, but includes a number of Haxe sources that are used in your game such as the code to setup Physics bodies and other interactions similar to how they behave in Blender.

### Shaders and Materials

The Armory renderer is completely separate from Blender, but it tries to make the games exported from Blender behave and looks as much as possible like the scene from Blender. Armory uses the Cycles material nodes to allow you to build shaders, but it does not stop you from writing your own if that is what you want to do. Armory has it's own version of the cycles materials that are suitable for the game runtime while still trying to look as much as possible like the cycles equivalents.

### Animation

Animations are also done in Blender. Actions designed in Blender become playable animations in your Armory game.

### Coding

Coding is handled with "Traits", a concept developed in Iron. Each object and scene can have any number of traits applied to them and there are at least a couple different kinds of traits.

#### Haxe Code

Haxe traits allow you to tie any Haxe code to an object in the Blender interface. The Haxe traits get full access to the entire Kha, Iron, and other APIs for controlling the object's behavior or influencing the rest of the scene.

#### Logic Nodes

Logic nodes are another way to write traits in Armory. Armory has an ever growing list of logic nodes that allows you to build out logic in a graphical manner right inside of Blender without having to write code. When your game is exported, the logic nodes will be compiled to Haxe to build the traits. This means that logic nodes have no performance disadvantage to other game code. If the shipped logic nodes are not sufficient for a task, it is also very easy to [write your own](/dev/logicnodes) logic nodes.
